using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace XorInterceptor;

[Generator]
public sealed class XorStringGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static pi =>
        {
            pi.AddSource("XorSupport.g.cs",
                """
                // <auto-generated />
                using System;
                namespace System.Runtime.CompilerServices
                {
                    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
                    internal sealed class InterceptsLocationAttribute : Attribute
                    {
                        public InterceptsLocationAttribute(int version, string data) { }
                    }
                }
                namespace XorInterceptor
                {
                    internal static class XorEncryption
                    {
                        public static string Xor() => string.Empty; // comment-only form
                    }
                }
                """);
        });

        var seedProvider = context.AnalyzerConfigOptionsProvider
            .Select((opts, _) =>
                opts.GlobalOptions.TryGetValue("build_property.XorBuildSeed", out var v) ? v : "1");

        var xorCalls =
            context.SyntaxProvider.CreateSyntaxProvider(
                    (node, _) => IsXorInvocation(node),
                    (ctx, _) => ExtractStringFromCallingMethod(ctx))
                .Where(static info => info is not null)
                .Select(static (info, _) => info!.Value);

        var callsWithSeed = xorCalls.Combine(seedProvider)
            .Select(static (p, _) => (p.Left.Location, p.Left.Literal, p.Right));

        context.RegisterSourceOutput(callsWithSeed.Collect(), static (spc, calls) => Execute(spc, calls));
    }

    private static bool IsXorInvocation(SyntaxNode node)
    {
        if (node is not InvocationExpressionSyntax inv) return false;

        var isName =
            inv.Expression is IdentifierNameSyntax { Identifier.Text: "Xor" } or MemberAccessExpressionSyntax { Name.Identifier.Text: "Xor" };
        return isName && inv.ArgumentList is { Arguments.Count: 0 };
    }

    private static (InterceptableLocation Location, string Literal)? ExtractStringFromCallingMethod(GeneratorSyntaxContext ctx)
    {
        var inv = (InvocationExpressionSyntax)ctx.Node;

        var al = inv.ArgumentList;
        if (al.Arguments.Count != 0)
        {
            return null;
        }

        var inside = al.OpenParenToken.TrailingTrivia.Concat(al.CloseParenToken.LeadingTrivia).ToList();
        if (inside.Count == 0)
        {
            return null;
        }

        var comments = inside.Where(t => t.IsKind(SyntaxKind.MultiLineCommentTrivia)).ToList();
        if (comments.Count != 1)
        {
            return null;
        }

        if (inside.Any(t => !(t.IsKind(SyntaxKind.WhitespaceTrivia) || t.IsKind(SyntaxKind.MultiLineCommentTrivia))))
        {
            return null;
        }

        // Extract the quoted text from the /* ... */ comment.
        var text = comments[0].ToString();

        var firstQuote = text.IndexOf('"');
        if (firstQuote < 0)
        {
            return null;
        }

        var secondQuote = text.IndexOf('"', firstQuote + 1);
        if (secondQuote < 0)
        {
            return null;
        }

        var literal = text.Substring(firstQuote + 1, secondQuote - firstQuote - 1);

#pragma warning disable RSEXPERIMENTAL002
        var loc = ctx.SemanticModel.GetInterceptableLocation(inv);
#pragma warning restore RSEXPERIMENTAL002
        if (loc is null) return null;

        return (loc, literal);
    }

    private static void Execute(
    SourceProductionContext context,
    ImmutableArray<(InterceptableLocation Location, string Literal, string BuildSeedText)> calls)
    {
        if (calls.IsDefaultOrEmpty) return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("namespace XorInterceptor {");
        sb.AppendLine("  internal static class XorInterceptors {");

        for (var idx = 0; idx < calls.Length; idx++)
        {
            var (location, literal, buildSeedText) = calls[idx];

            _ = int.TryParse(buildSeedText, out var buildSeed);

            var siteSeed = (buildSeed ^ idx) | 1;
            var chars = literal.ToCharArray();
            var key = new ushort[chars.Length];
            var enc = new ushort[chars.Length];

            for (var i = 0; i < chars.Length; i++)
            {
                key[i] = (ushort)(siteSeed + i);
                enc[i] = (ushort)(chars[i] ^ key[i]);
            }

            var encArr = string.Join(", ", enc.Select(x => $"0x{x:X4}"));
            var keyArr = string.Join(", ", key.Select(x => $"0x{x:X4}"));
            var data = location.Data.Replace("\\", "\\\\").Replace("\"", "\\\"");

            sb.AppendLine($"    [InterceptsLocation({location.Version}, \"{data}\")]");
            sb.AppendLine($"    internal static string XorIntercepted_{idx}()");
            sb.AppendLine("    {");
            sb.AppendLine($"      ReadOnlySpan<ushort> enc = new ushort[] {{ {encArr} }};");
            sb.AppendLine($"      ReadOnlySpan<ushort> key = new ushort[] {{ {keyArr} }};");
            sb.AppendLine("      Span<char> dst = enc.Length <= 512 ? stackalloc char[enc.Length] : new char[enc.Length];");
            sb.AppendLine("      for (int i = 0; i < enc.Length; i++) dst[i] = (char)(enc[i] ^ key[i]);");
            sb.AppendLine("      return string.Create(dst.Length, dst, static (span, d) => d.CopyTo(span));");
            sb.AppendLine("    }");
        }

        sb.AppendLine("  }");
        sb.AppendLine("}");
        context.AddSource("XorStringInterceptors.g.cs", sb.ToString());
    }
}